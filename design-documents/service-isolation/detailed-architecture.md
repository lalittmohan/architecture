# Detailed architecture of multi-service Magento

## Overview

The goal of this document is to gather requirements, understand data flow and propose architecture for multi-service storefront Magento application. Admin use cases are intentionally out of scope.

Please make sure to get familiar with [high-level service isolation vision](../service-isolation.md) before proceeding.

![Gateway](img/multi-service-structure.png)

To avoid cluttering the above diagram, response arrows are omitted. Most queries in reality are synchronous.

The client (e.g. browser) is interacting with the system using GraphQL. The only component of the system exposed publicly is Storefront Gateway, which is responsible for routing, full response caching and perimeter-level authorization.

Storefront Gateway routes incoming queries between PWA, GraphQL Engine and Storefront Authentication Gateway. To simplify implementation we can also route admin calls through the same gateway.

PWA's main responsibility is to [render React application on the server-side](../frontend/server-side-rendering.md). Resulting HTML page with React application becomes cacheable on the server.

GraphQL server parses GraphQL query, enriches the request (explained later) and proxies calls to the Storefront services. It also manages Customer context JWT. GraphQL schema is defined here and is extensible, query resolution is based on generic resolvers and configuration for field mapping to Storefront APIs.

Storefront services are responsible for authorizing requests based on the Auth JWT and the list of required permissions. Actual ACL check is delegated to the the Authorization service.

GraphQL authentication gateway is an independent service for improved security purposes, although it can be merged with GraphQL server.

The storefront services are communicating with each other using REST or Protobuf protocol. Storefront APIs are implemented as service contracts exposed via REST/Protobuf.

Integration with third-party systems can be implemented in one of the following ways depending on use case:
 1. Storefront Gateway may route query to third-party system
 1. Storefront Gateway may provide service discovery for third-party systems, in this case the client will call third-party system directly 
 1. Third-party system can be placed behind GraphQL engine and exposed via unified GraphQL schema. For example when Magento storefront services are replaced with services from Commerce SaaS
 
Observability of the incoming/outgoing traffic is an important aspect of SaaS applications and corresponding design should be created in the future iterations of this proposal.

## Authentication, Store and Customer contexts

**Auth JWT** - authentication token, which contains signed customer ID and is used on GraphQL Server to authenticate the logged-in customers.
 This token is generated by the storefront authentication server in response to the request containing valid customer credentials.
 Customer ID is not encrypted and is visible to all parties including the client application.

**Customer Context JWT** - contains encrypted customer data, which should be used for cache key generation and MUST not be modifiable by the client due to its sensitivity. Examples include customer group and customer segment. 
 Customer Context MUST not include any customer data not relevant for cache scoping, for example customer ID. The token can be used as is for cache key generation and does not require parsing by caching layer. 
 This token is generated by GraphQL Server and the list of customer data included in the token must be extensible. The data itself is encrypted and decrypted by GraphQL server only, encryption secret MUST NOT be shared with any other services. 

**Token Service** - authentication and customer context tokens will be signed with private key by the Token service, this private key MUST NOT be shared with any other services. All other parties will be able to validate signature using public key. 
 
**Store Context** - a set of headers that contain scoping information applicable to the majority of the queries. Examples include store code and currency. These headers are optional. The client application is responsible for tracking scoping values selected by the customer and sending them with all subsequent requests in headers.

Auth JWT, Customer Context JWT and Store Context are all optional, however, when present in the original client request, they MUST be retransmitted along with all subsequent calls to Magento services. They should not be retransmitted with the calls to the third-party systems.
 
The following sequence diagram demonstrates the process of client application obtaining authentication and customer context JWTs.

![Customer authentication](img/multi-service-customer-authentication-sequence.png)

Individual storefront services are responsible for verifying that user is authorized to perform specific action.

![Customer authentication](img/multi-service-customer-authorization-sequence.png)
 
## Query enrichment

When the user visits Magento storefront for the first time, pages that support scoping (like category page) must be rendered based on default scopes.
Client application may send query with no currency, store code and customer context. At the same time, catalog storefront API requires store code, currency and customer group to be passed as explicit arguments. 
The solution is to have GraphQL query enriched by the GraphQL server. Enrichment logic cannot be moved to storefront gateway because of couple reasons:
 - it requires GraphQL query to be parsed
 - it relies on customer context arguments to be decoded. This can be done only by GraphQL server which owns corresponding encoding secret
 
Data lookup for storefront API query enrichment will be done using the following sources in the specified order:
 1. Customer ID will always be taken from the Authentication JWT
 1. Customer group, customer segment and any extensions to the customer context will always be taken from the Customer Context JWT
 1. Data from GraphQL query body
 1. Data from store context headers
 1. Defaults from GraphQL Server cache
 1. Preconfigured defaults via calls to storefront services. For example, default customer group based on current store code. The list of defaults with corresponding sources MUST be configurable
 
The following diagram explains a sequence of actions needed to render a product page with PWA. After the initial call caches on server, gateway and client side will make this sequence shorter.

![Product details page rendering with PWA](img/multi-service-pwa-sequence.png)

#### Alternative evaluation

Storefront services may be responsible for query enrichment instead of relying on GraphQL Server for this. This will simplify implementation of the GraphQL Server, but will introduce additional inter-dependencies between services, which in turn will increase complexity and negatively affect performance.

## Scalability

All components must support scalability.

PWA SHOULD NOT be deployed in multi-service mode due to inability to achieve ultimate performance optimization in this case. See details on micro frontends [here](https://martinfowler.com/articles/micro-frontends.html).

## Extensibility

Extensibility is extremely important for Magento and multi-service Magento is not an exception. 

Most of the components need to be extensible, including:
 - GraphQL Server and any custom BFFs
 - PWA
 - Domain services
 - List of supported authentication mechanisms
 - Access control list (ACL) 
 
Storefront Gateway may not need to be extensible.

It is important to note that services have to be redeployed after installation of extensions. It should be possible to manage ACL via admin API gateway to avoid the need of redeployment.
